import numpy as np


def gibbs_assign(likelihood, n_samples=1000):
    """
    Approximates LMB weights by using assignments generated by Gibbs Sampling

    Parameters
    ----------
    likelihood:     LMB likelihood
    n_samples:      no. of samples to draw

    Returns         approximated LMB weights
    -------

    """

    likelihood_nonzero = np.maximum(likelihood, 1e-6)
    r = likelihood.shape[0]
    c = likelihood.shape[1]
    lmb_weights = np.zeros((r, c), dtype=np.float64)

    # define cyclic assignment and assign to non-blocking column
    assignment = np.zeros(r, dtype=np.int64)

    # blocked measurements cannot be assigned
    blocked = np.zeros(c, dtype=np.int64)

    tt_range = np.arange(r)  # indices of targets
    gibbs_costs = np.zeros(n_samples, dtype=np.float64)  # costs of gibbs assignments
    sol_id = 0
    for q in range(n_samples):

        rand_cost = np.random.rand(r, c) * likelihood

        gibbs_costs[sol_id] = 1.0
        # inner iteration over rows
        for i in range(r):
            # lift assignment for current sample and last column (non-blocking)
            blocked[assignment[i]] = 0
            blocked[0] = 0  # first two columns are non-blocking
            blocked[1] = 0

            # sample
            assignment[i] = np.argmax(rand_cost[i] * (1 - blocked))  # blocked measurements have prob. 0

            blocked[assignment[i]] = 1  # block measurement

            # update weight for current assignment
            gibbs_costs[sol_id] *= likelihood_nonzero[i, assignment[i]]

        # compare to existing solutions
        duplicate_found = False
        for s in range(sol_id):
            if gibbs_costs[sol_id] == gibbs_costs[s]:
                duplicate_found = True
                break
        if not duplicate_found:
            lmb_weights[tt_range, assignment] += gibbs_costs[sol_id]

            # go to next cycle
            sol_id += 1

    norm = np.sum(gibbs_costs[:sol_id])
    lmb_weights /= norm
    return lmb_weights
