import numpy as np
from scipy.optimize import linear_sum_assignment


def murty(cost_matrix, num_samples, blocksize=1000):
    """
    Computes the num_samples best assignments, considering cost_matrix
    Parameters
    ----------
    cost_matrix:    cost matrix of the linear assignment problem
    num_samples:    no. of samples to computer
    blocksize:      blocksize for space allocation

    Returns         the num_samples best assignments and corresponding costs
    -------

    """
    inf = 1e42

    num_rows, num_cols = cost_matrix.shape
    tt_range = np.arange(num_rows)
    # find best assignment
    r_idx, assignment_0 = linear_sum_assignment(cost_matrix)
    cost_0 = cost_matrix[r_idx, assignment_0].sum()

    # allocate space for assignments
    assignments = np.zeros((num_samples, num_rows), dtype='i8')
    costs = np.zeros(num_samples, dtype='f8')

    # allocate space for queue
    answer_list_CM = np.zeros((blocksize, num_rows, num_cols), dtype=np.float64)  # cost matrices
    answer_list_A = np.zeros((blocksize, num_rows), dtype=np.int64)  # assignments
    answer_list_C = np.nan * np.ones(blocksize, dtype=np.float64)  # costs
    CM_tmp = np.zeros(cost_matrix.shape, dtype=cost_matrix.dtype)
    CM_now = np.zeros(cost_matrix.shape, dtype=cost_matrix.dtype)

    # initialize answer list
    answer_list_CM[0] = cost_matrix  # problem or cost matrices
    answer_list_A[0] = assignment_0  # solutions or assignments
    answer_list_C[0] = cost_0  # cost of solution

    answer_index_next = 0

    if num_samples == 1:
        assignments[0] = assignment_0
        costs[0] = cost_0
        return assignments, costs

    for i in range(num_samples):
        # if all are cleared, break loop early
        if np.all(np.isnan(answer_list_C)):
            assignments = assignments[:answer_index_next + 1]
            costs = costs[:answer_index_next + 1]
            break

        # grab lowest cost solution index
        idx_top = np.nanargmin(answer_list_C[:answer_index_next + 1])

        # save current best solution
        assignments[i] = answer_list_A[idx_top]
        costs[i] = answer_list_C[idx_top]

        # copy lowest cost problem to temp
        CM_now[:] = answer_list_CM[idx_top]
        A_now = answer_list_A[idx_top]

        # delete solution from queue
        answer_list_C[idx_top] = np.nan

        # find solutions for subproblem
        for aw, aj in enumerate(A_now):

            if aj != -1:  # -1 is not assigned
                # remove it an calculate new solution
                CM_tmp[:] = CM_now

                CM_tmp[aw, aj] = inf
                r_idx, A_tmp = linear_sum_assignment(CM_tmp)
                C_tmp = CM_tmp[r_idx, A_tmp].sum()

                # if all assignments are valid
                if np.all(CM_tmp[tt_range, A_tmp] < inf):
                    # if answer list is full, allocate more
                    if answer_index_next >= answer_list_C.shape[0]:
                        answer_list_CM = np.concatenate(
                            (answer_list_CM, np.zeros((blocksize, num_rows, num_cols), dtype=np.float64)))
                        answer_list_A = np.concatenate((answer_list_A, np.zeros((blocksize, num_rows), dtype=np.int64)))
                        answer_list_C = np.concatenate((answer_list_C, np.nan * np.ones(blocksize, np.float64)))

                    answer_list_CM[answer_index_next][:] = CM_tmp
                    answer_list_A[answer_index_next][:] = A_tmp
                    answer_list_C[answer_index_next] = C_tmp
                    answer_index_next += 1

                # enforce current assignment
                v_tmp = CM_now[aw, aj]
                CM_now[aw, :] = inf
                CM_now[:, aj] = inf
                CM_now[aw, aj] = v_tmp

    return assignments[:answer_index_next + 1], costs[:answer_index_next + 1]


def murty_wrapper(likelihood, num_samples=1000):
    """
    Approximates LMB weights by using assignments generated by Murty's Algorithm
    Parameters
    ----------
    likelihood:     LMB likelihood
    num_samples:    no. of samples to draw

    Returns         approximated LMB weights
    -------

    """
    inf = 1e42
    T, Z = likelihood.shape
    Z -= 2
    eps = 1e-16

    # compute extended cost matrix
    tt_range = np.arange(T)
    cost = np.zeros((T, T + T + Z), dtype=np.float64)
    cost[:, :2 * T] = inf
    cost[tt_range, tt_range] = - np.log(likelihood[:, 0] + eps)  # death
    cost[tt_range, tt_range + T] = - np.log(likelihood[:, 1] + eps)  # missed detection
    cost[tt_range, 2 * T:] = - np.log(likelihood[:, 2:] + eps)  # measurements

    # run murty
    assignments, costs = murty(cost, num_samples)
    # remap assignments
    assignments[assignments < T] = 0  # deaths
    assignments[np.logical_and(assignments >= T, assignments < 2 * T)] = 1  # missed detection
    assignments[assignments >= 2 * T] += 2 - 2 * T  # measurements
    print(assignments - 1)
    # compute weight matrix
    weights = np.zeros(likelihood.shape, dtype=np.float64)
    for a, c in zip(assignments, costs):
        weights[tt_range, a] += np.exp(-c)

    norm = np.sum(np.exp(-costs))
    weights /= norm
    return weights
